class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        ROWS, COL= len(board), len(board[0])

        def dfs(r,c,i):
            #found word
            if i==len(word):
                return True

            #checking bounds
            if (r<0 or c<0 or r >= ROWS or c >= COL or board[r][c]!=word[i]):
                return False

            temp=board[r][c] #store the value of currect board char
            board[r][c]="#"

            res = (dfs(r+1,c, i+1) or 
                    dfs(r,c+1, i+1) or 
                    dfs(r,c-1, i+1) or
                    dfs(r-1,c, i+1))
            board[r][c]= temp #you wanna replace back the "#"
            return res
            

        for i in range(ROWS):
            for j in range(COL):
                #if element== chaacter of the string we are tyring to choose
                if dfs(i,j,0):
                    return True
        return False
###########################################################     
--complex: O(m* 4^^n) m= number of cells in board. 
1) Visited is path-specific, not global
When you call dfs(r, c, i), you’re exploring one specific path trying to match word[i:]. Marking board[r][c] = "#"  prevents revisiting the same cell within this path, which would cause cycles like (r, c) → … → (r, c).
2) Multiple starts need a clean board
Your outer loop tries every cell as a starting point:
If you didn’t restore, any cell touched by an earlier failed attempt would remain "#", breaking future valid searches that start elsewhere.
